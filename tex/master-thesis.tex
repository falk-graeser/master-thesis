\documentclass[10pt,a4paper]{book}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{csquotes}
\usepackage[
backend=biber,
style=alphabetic,
citestyle=authoryear
]{biblatex}
\addbibresource{literature.bib}

\author{Falk Gräser}

\title{Entwicklung von Visualisierungs- und Integrationsansätzen für Continuous-Integration und Feature-Branches}

\begin{document}

\maketitle

\tableofcontents

\chapter{Einleitung}

Software ist kein Selbstzweck. Software wird entwickelt und ausgeliefert um die Anforderungen eines oder mehrer Kunden zu erfüllen.

\chapter{Problemanalyse}

% In diesem Kapitel muss ich darstellen was Contiuous Integration bedeutet, wofür es verwendet wird und welche Tücken es mit sich bringt.
% Ebenso für Feature Branches.
% Und ich muss darstellen, warum Martin Fowler darüber geschrieben hat, dass 

%"When you isolate the feature branches, there is a risk of a nasty conflict growing without you realizing it"
%https://martinfowler.com/bliki/FeatureBranch.html

Die Zusammenführung der Arbeit von mehr als einem Entwickler ist ein komplexer und nicht trivialer Vorgang. \\
Viele Teile eines Softwareprojektes beeinflussen andere und häufig werden an Schnittstellen in Programmen Änderungen von mehreren Entwicklern vorgenommen. \\
Es muss sichergestellt werden, dass die Änderungen zusammengeführt werden können und dass das Ergebnis den Anforderungen entspricht.

Gerade wenn die Software einen gewissen Umfang übersteigt, ist daher ein solides Anforderungsmanagement essenziell. Zudem müssen Mechanismen geschaffen werden um sicher zustellen, dass diese Anforderungen über die komplette Laufzeit der Software erfüllt bleiben. 

Leider sieht die Realität in der Softwareentwicklung nicht selten anders aus. Fehlende, nicht dokumentierte oder veraltet Anforderungen sind keine Seltenheit.\\
Ebenso sind lange Zeitintervalle indenen sich Teile der Software in keinem lauffähigen oder einem fehlerbehaftetem Zustand befinden Normalität.

In diesen Fällen wir häufig erst zum Zeitpunkt des Testes - oder schlimmer - zum Zeitpunkt der Auslieferung, die Situation offenbart.

Die Gründe für diese Schwierigkeiten sind häufig in kein homogenes Bild zu bringen. Vielmehr tragen verschiedene Faktoren dazu bei, die erst in der Kombination zu erheblichen Problemen führen können.

\section{Vorgehensmodelle}
\paragraph{Hinweis}

\begin{itemize}
\item evtl. Untergliederung in phasen orientierte und iterations orientierte Vorgehensmodelle
\item  evtl. Untergliederung Anforderungsmangement?
\item Schluss warum moderne Vorgehenmodell die Benutzung von dezentralen Versionverwaltungen gefördert und gefordert haben
\item Schluss warum iterative Vorgehen Continuous Integration fordern
\end{itemize}

\vspace{1em}

Um Herr über diese Probleme zu werden wurde lange Zeit versucht über statische und umfangreiche Vorgehensmodelle (Wasserfallmodell, V-Modell) und vollständig ausformulierte Anforderungsdokumentationen mit Lasten- und Pflichtenheften ein klares Bild zu schaffen und Risiken zu fehlenden oder unklaren Anforderungen zu minimieren.

Da trotz dieser Mittel immer noch zahlreiche Projekte scheiterten, wurden neue Wege gesucht um die bestehenden Probleme zu lösen.

Kind dieser Suche war unter anderem die Agile Bewegung, sicherlich nicht unwesentlich beeinflusst durch die Veröffentlicheungen von Kent Beck. Die Bewegung suchte sich von den traditionellen Modellen zu lösen und prägnante Lösungen zu finden.\\
Beinflusst von der Lean-Bewegung aus der Automobil-Fertigungsindustrie wurden zentrale Punkte, die das Verständis von Agiler Softwareentwicklung verdeutlichen sollte, im Agilen Manifest festgehalten.

Das Agile Manifest stellt hohe Ansprüche an Entwickler und erzwingt ein Umdenken im Umgang mit dem Projektprozess. Während in traditionellen Vorgehensmodellen jede Phase eine längere zeitliche Periode einnimmt, so werden diese Phasen und Zeiträume in agilen Vorgehen deutlich verkürzt, um damit einhergehende Informationsflüsse deutlich zu beschleunigen.
Diese kurzen Zeiträume und damit einhergehenden vielen Iterationen geben kontinuierlich und schnell Auskunft über den Zustand eines Projektes. Außerdem wird es einfacher zu erkennen, welche Schritte tatsächlich wertvoll sind und welche Schritte dem Projektfortschritt eher abträglich sind. 

Oberstes Ziel hierbei ist die Lieferung von "wertvoller" Software, also die Einschätzung der Anforderungen mit den Stakeholdern und priorisierte Lieferung dieser Anforderungen.

Dieses Vorgehen führt automatisch dazu, dass frühzeitig deutlich wird, ob die richtigen Anforderungen als wichtig erkannt wurden und welche Anforderungen implizit angenommen und daher im verborgenen lagen.

Ein weiterer Aspekt "wertvoller" Software ist ihre Funktionalität. Diese sicherzustellen in einer kontinuierlichen Auslieferung erfordert ein hohes Maß an Qualitätssicherung. Schon sehr früh im Entwicklungsprozess eines iterativ wachsenden Systems wird deutlich, dass keine menschliche Resource mehr im Stande ist, alle Anforderungen mit jeder Auslieferung zu testen und die Qualität sicherzustellen. Die Automatisierung dieser Tests ist somit unausweichlich.

\section{Qualitätssicherung und Softwaretest}

Die Qualitätssicherung einer Software muss als oberste Prämisse sicherstellen, dass alle Anforderungen erfüllt sind und dass die Anforderungen auch erfüllt bleiben. Nicht selten führen Neuerungen in einer Software dazu, dass bereits bestehenden Funktionalität beeinträchtigt wird. 
Aufbauend auf der Annahme, dass alle notwendigen Anforderungen beschrieben sind, müssen diese in unterschiedlichen Stufen überprüft und sichergestellt werden.

Die Entscheidung was getestet wird und wann es getestet wird hängt dabei von verschiedenen Faktoren ab.

\section{Automatisierung der Softwareerstellung - Continuous Building}

\subsection{Kodeverwaltung und Versionskontrollsysteme}
\subsection{Configurations Management}
\subsection{Dependency Management}
\subsection{Automatisierte Erstellung}
\subsection{Validierung und Test}

\section{Feature Branches}

\section{Continuous Integration}

\chapter{Visualisierung und Methodiken}

\begin{itemize}
\item Metriken um Branches zu beurteilen
\item automatisierte Releasekombination
\item automatisierte Konflikterkennung
\item Regeln, wie 
	\begin{itemize}
		\item nur FastForward-Merges erlauben
	\end{itemize}	 
\item Buildautomatisierung
\item Continuous Delivery
\item Configuration Management
\item verschiedene Sichten, u.a. Feature-Sicht mit Goals?
\end{itemize}

\chapter{Zusammenfassung}


\chapter{Literaturverzeichnis}

\printbibliography

\end{document}