\chapter{Zusammenfassung}

Continuous-Integration und Feature-Branches schließen sich nicht generell aus. Beide Verfahren können sich ergänzen, wenn Abstriche hingenommen werden. Die Grundidee ist, Konflikte zwischen Feature-Branches frühzeitig zu erkennen. Dafür können die Feature-Branches automatisiert verglichen und frühzeitig Integrationskonflikte kommuniziert werden. Im nächsten Schritt werden alle Feature-Branches ohne Integrationskonflikte automatisch durch einen Merge zusammengeführt. Diese automatisch integrierten Feature-Branches werden abschließend durch einen Software-Build validiert. Auf diese Weise entsteht für alle konfliktfreien Feature-Branches ein Continuous-Integration naher Zustand.

Aufbauend auf diesem Ansatz, können die Vorteile von Feature-Branches genutzt werden, um die Nachteile von Continuous-Integration teilweise zu umgehen oder abzuschwächen.

Feature-Branches verzögern die Integration von entwickelten Änderungen. Dieser Nachteil in kollaborativer Software-Entwicklung wird durch die Kombination mit Continuous-Integration abgeschwächt. Der Vorteil der verzögerten Integration ist die Möglichkeit einen Code-Review durchzuführen, bevor die Änderung Teil der Softwareanwendung wird. 

Darauf aufbauend können entwickelte Änderungen vollständig getestet werden, bevor die Integration erfolgt. Continuous-Integration stellt die Integrität des Software-Inkrementes sicher. Scheitert diese Validerung fordert der Prozess von Continuous-Integration die Wiederherstellung der Integrität. Während dieser Wiederherstellung ist die Softwareentwicklung blockiert und kann keine neuen Software-Inkremente validieren. Feature-Branches umgehen die Blockade. Scheitert die Validerung eines Feature-Branches, sind entwickelte Änderungen auf anderen Branches nicht betroffen. Somit ist ein differenzierteres Vorgehen zur Beseitigung der fehlgeschlagenen Validierung möglich.

\section{Kritik}

Die kritische Betrachtung der angeführten Variante zur Kombination von Continous\hyp{}Integration und Feature-Branches führt zu einem Problem. Der Continous-Integration nahe Zustand existiert nur für Feature-Branches ohne Merge-Konflikte. Diese Merge-Konflikte müssen manuell behoben werden. Als Resultat sind die beiden Branches in der Weiterentwicklung voneinander abhängig. Diese beiden Branches führen ab diesem Zeitpunkt einen \glqq klassischen\grqq{} Continous-Integration-Prozess durch. Weisen alle Feature-Branches einen Konflikt auf, müssen alle Feature-Branches zusammengeführt werden. Das Resultat wäre ein \glqq erschwerten\grqq{} Continous-Integration-Prozess.

Neben den technischen Schwierigkeiten existieren weitere. Der hohe Grad an Automatisierung und technischer Komplexität des Vorgehens, stellt hohe Anforderungen an den Softwareentwickler. Ähnlich wie bei vielen agilen Methoden wird ein hohes Maß an Selbstdisziplin vorausgesetzt. Hinzu kommt ein hoher initialer Aufwand. Sowohl die Einarbeitung in alle relevanten Themen, als auch initiale Einrichtung des Continuous-Delivery-Prozesses fordern den Softwareentwickler.

\section{Lösungsansatz}

Das Gedankenexperiment zum erschwerten Continuous-Integration-Prozess offenbart die Schwäche der Methodik. Um dieses Szenario zu verhindern, müssen Konflikte bereits im Vorfeld durch die existierenden Methodiken der Softwarearchitektur minimiert werden. Im Umfeld der Softwareentwicklung mit Continuous-Integration sind solche Methodiken bereits bekannt. Insbesondere durch Modularisierung der Software-Anwendung können viele Konflikte verhindert werden. Auch durch Test-First-Ansätze werden Softwareanwendungen modularer und klarer strukturiert. Diese Ansätze fördern unter anderem \glqq lose gekoppelte\grqq{}  Softwarearchitekturen, da diese leichter durch Tests validiert werden können. 

Unabhängig von den gewählten Entwicklungsansätzen können durch Metriken\\ Schwachpunkte in den Softwarekomponenten gefunden werden. Hohe Komplexität oder Komponenten mit besonders vielen Abhängigkeiten lassen sich gut durch Metriken ausfindig machen. Visualisierung der Metriken erleichtern deren Interpretation bei besonders umfangreichen Softwareanwendungen. 

\section{Ausblick}

Die weitere Betrachtung des Themas könnte vor allem in zwei Richtungen führen. Zum einen kann der eigentliche Vorgang verbessert werden, Änderungen mit einem Merge zusammenzuführen. Es existieren bereits semantische Verfahren, um die Durchführung eines Merge zu optimieren. Dadurch treten weniger Merge-Konflikte auf. Ebenso existieren Studien, die existierende Software-Repositories analysieren. Die darin existierenden Merge-Entscheidungen werden genutzt, um ein neurales Netz anzulernen. Beide Verfahren haben das Potential die Kombination aus Continuous-Integration und Feature-Branches effizienter zu gestalten.

Die zweite Richtung ist die weitere Standardisierung von Software. In einem vollständig entkoppelten System würden theoretisch nahezu keine Merge-Konflikte auftreten. Nahezu jeder Feature-Branch, der die automatische Validierung besteht, kann somit integriert werden. Angewendet innerhalb eines vollständig automatisierten Continuous-Deployment-Prozesses ergeben sich somit zahlreiche Möglichkeiten. Ein entsprechend aufgestelltes Entwicklungsteam, kann neue Änderungen direkt auf dem Produktivsystem evaluieren. Ein fortschrittlicher Continuous-Deployment-Prozess stellt die Möglichkeit bereit, eine sehr kleine Gruppe an Nutzern auszuwählen und nur diesen die Änderung anzubieten.

Die Softwareentwicklung hat in den letzten 30 Jahren zahlreiche neue Konzepte entwickelt und in der Praxis erprobt. In spannenden und hitzig geführte Diskussionen wurde darüber gestritten. Viele der entstandene Konzepte haben die Softwareentwicklung nachhaltig geprägt. Die agile Softwareentwicklung ist das wohl prominenteste Beispiel dafür. Zahlreiche Konzepte und Methoden sind aus den Ideen und Sichtweisen der agilen Softwareentwicklung entstanden. Welche neuen Verfahren die Softwareentwicklung hervorbringt, bleibt offen. Wie bessere semantische Verfahren und der Einsatz von maschinellem Lernen die Softwareentwicklung verändern werden, wird die Zukunft zeigen. Eines bleibt jedoch sicher, die Softwareentwicklung wird auch weiterhin große Herausforderung bereithalten.

\blockquote {For a long time it puzzled me how something so expensive, so leading edge, could be so useless. And then it occurred to me that a computer is a stupid machine with the ability to do incredibly smart things, while computer programmers are smart people with the ability to do incredibly stupid things. They are, in short, a perfect match. \\- Bill Bryson}
