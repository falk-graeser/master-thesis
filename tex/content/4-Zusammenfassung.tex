\chapter{Zusammenfassung}

Continuous-Integration und Feature-Branches schließen sich nicht generell aus. Beide Verfahren können sich ergänzen, wenn Abstriche hingenommen werden. Die Grundidee ist, Konflikte zwischen Feature-Branches frühzeitig zu erkennen. Dafür können die Feature-Branches automatisiert verglichen und frühzeitig Integrationskonflikte kommuniziert werden. Im nächsten Schritt werden alle Feature-Branches ohne Integrationskonflikte automatisch durch einen Merge zusammengeführt. Diese automatisch integrierten Feature-Branches, werden abschließen durch einen Software-Build validiert. Auf diese Weise entsteht für alle Feature-Branches ohne Konflikt, ein Continuous-Integration naher Zustand.

Aufbauend auf diesem Ansatz, können die Vorteile von Feature-Branches genutzt werden, um die Nachteile von Continuous-Integration teilweise zu umgehen oder abzuschwächen.

Feature-Branches verzögern die Integration von entwickelten Änderungen. Dieser Nachteil in kollaborativer Software-Entwicklung, wird durch die Kombination mit Continuous-Integration abgeschwächt. Der Vorteil der verzögerten Integration, ist die Möglichkeit ein Review durchzuführen, bevor die Änderung Teil der Softwareanwendung wird. 

Darauf aufbauend, können entwickelte Änderungen vollständig getestet werden, bevor sie integriert werden. Continuous-Integration stellt die Integrität des Software-Inkrementes sicher. Scheitert diese Validerung fordert der Prozess von Continuous-Integration die Wiederherstellung der Integrität. Während dieser Wiederherstellung ist die Softwareentwicklung blockiert und kann keine neuen Software-Inkremente validieren. Feature-Branches umgehen die Blockade. Scheitert die Validerung eines Feature-Branches, sind entwickelte Änderungen auf anderen Branches nicht betroffen. Somit ist ein differenzierteres Vorgehen zur Beseitigung der fehlgeschlagenen Validierung möglich.

\section{Kritik}

Die kritische Betrachtung der angeführten Variante zur Kombination von Continous\hyp{}Integration und Feature-Branches führt zu einem Problem. Der Continous-Integration nahe Zustand existiert nur für Feature-Branches ohne Merge-Konflikte. Diese Merge-Konflikte müssen manuell behoben werden. Als Resultat sind die beiden Branches in der Weiterentwicklung von einander abhängig. Diese beiden Branches führen ab diesem Zeitpunkt, einen \glqq klassischen\grqq{} Continous-Integration-Prozess durch. Weisen alle Feature-Branches einen Konflikt auf, müssen alle Feature-Branches zusammengeführt werden. Das Resultat wäre ein \glqq sehr spezieller\grqq{} Continous-Integration-Prozess.

\section{Lösungsansatz}

Dieses Gedankenexperiment offenbart die Schwäche der Methodik. Um dieses Szenario zu verhindern, müssen Konflikte bereits im Vorfeld, durch entsprechende Methodiken der Softwarearchitektur minimiert werden. Im Umfeld der Softwareentwicklung mit Continuous-Integration sind solche Methodiken bereits bekannt. Insbesondere durch Modularisierung der Software-Anwendung können viele Konflikte verhindert werden. Auch durch Test-First-Ansätze werden Softwareanwendungen modularer und klarer strukturiert. Diese Ansätze fördern unter anderem \glqq lose gekoppelte\grqq{}  Softwarearchitekturen, da diese leichter durch Tests validiert werden können. 

Unabhängig von den gewählten Entwicklungsansätzen, können durch Metriken\\ Schwachpunkte in den Softwarekomponenten gefunden werden. Hohe Komplexität oder Komponenten mit besonders viele Abhängigkeiten, lassen sich gut durch Metriken ausfindig machen. Visualisierung der Metriken erleichtern deren Interpretation bei besonders umfangreichen Softwareanwendungen. 

\section{Ausblick}

Die weitere Betrachtung des Themas könnte vor allem in zwei Richtungen führen. Zum einen kann der eigentliche Vorgang verbessert werden, Änderungen mit einem Merge zusammenzuführen. Es existieren bereits semantische Verfahren, um die Durchführung eines Merge zu optimieren. Dadurch treten weniger Merge-Konflikte auf. Ebenso existieren Studien, die existierende Software-Repositories analysieren. Die darin existierenden Merge-Entscheidungen werden genutzt, um ein neurales Netz anzulernen. Beide Verfahren können die Kombination aus Continuous-Integration und Feature-Branches deutlich verbessern.

Die zweite Richtung, ist die weiter Standardisierung von Software. In einem vollständig entkoppelten System, würden theoretisch keine Merge-Konflikte auftreten. Jeder Feature-Branch, der die automatische Validierung besteht, kann somit integriert werden. Angewendet innerhalb eines vollständig automatisierten Continuous-Deployment-Prozesses, ergeben sich somit zahlreiche Möglichkeiten. Ein entsprechend aufgestelltes Entwicklungsteam, kann neue Änderungen direkt auf dem Produktivsystem evaluieren. Ein fortschrittlicher Continuous-Deployment-Prozess stellt die Möglichkeit bereit, eine sehr kleine Gruppe an Nutzern auszuwählen und nur diesen die Änderung anzubieten.

Beide Richtungen interessante und tiefgreifende weiterführende Themen.