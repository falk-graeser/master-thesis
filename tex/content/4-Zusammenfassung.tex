\chapter{Zusammenfassung}

Continuous-Integration und Feature-Branches schließen sich nicht generell aus. Beide Verfahren können sich ergänzen, wenn Abstriche hingenommen werden. Die Grundidee ist, Konflikte zwischen Feature-Branches frühzeitig zu erkennen. Dafür können die Feature-Branches automatisiert verglichen und frühzeitig Integrationskonflikte kommuniziert werden. Im nächsten Schritt werden alle Feature-Branches ohne Integrationskonflikte automatisch durch einen Merge zusammengeführt. Diese automatisch integrierten Feature-Branches werden abschließend durch einen Software-Build validiert. Auf diese Weise entsteht für alle konfliktfreien Feature-Branches ein Continuous-Integration naher Zustand.

Aufbauend auf diesem Ansatz, können die Vorteile von Feature-Branches genutzt werden, um die Nachteile von Continuous-Integration teilweise zu umgehen oder abzuschwächen.

Feature-Branches verzögern die Integration von entwickelten Änderungen. Dieser Nachteil in kollaborativer Software-Entwicklung wird durch die Kombination mit Continuous-Integration abgeschwächt. Der Vorteil der verzögerten Integration ist die Möglichkeit einen Code-Review durchzuführen, bevor die Änderung Teil der Softwareanwendung wird. 

Darauf aufbauend können entwickelte Änderungen vollständig getestet werden, bevor die Integration erfolgt. Continuous-Integration stellt die Integrität des Software-Inkrementes sicher. Scheitert diese Validerung fordert der Prozess von Continuous-Integration die Wiederherstellung der Integrität. Während dieser Wiederherstellung ist die Softwareentwicklung blockiert und kann keine neuen Software-Inkremente validieren. Feature-Branches umgehen die Blockade. Scheitert die Validerung eines Feature-Branches, sind entwickelte Änderungen auf anderen Branches nicht betroffen. Somit ist ein differenzierteres Vorgehen zur Beseitigung der fehlgeschlagenen Validierung möglich.

\section{Kritik}

Die kritische Betrachtung der angeführten Variante zur Kombination von Continuous\hyp{}Integration und Feature-Branches führt zu einem Problem. Der Continuous-Integration nahe Zustand existiert nur für Feature-Branches ohne Merge-Konflikte. Diese Merge-Konflikte müssen manuell behoben werden. Als Resultat sind die beiden Branches in der Weiterentwicklung voneinander abhängig. Diese beiden Branches führen ab diesem Zeitpunkt einen \glqq klassischen\grqq{} Continuous-Integration-Prozess durch. Weisen alle Feature-Branches einen Konflikt auf, müssen alle Feature-Branches zusammengeführt werden. Das Resultat wäre ein \glqq erschwerter\grqq{} Continuous-Integration-Prozess.

Neben den technischen Schwierigkeiten existieren weitere. Der hohe Grad an Automatisierung und technischer Komplexität des Vorgehens, stellt hohe Anforderungen an den Softwareentwickler. Ähnlich wie bei vielen agilen Methoden wird ein hohes Maß an Selbstdisziplin vorausgesetzt. Hinzu kommt ein hoher initialer Aufwand. Sowohl die Einarbeitung in alle relevanten Themen, als auch initiale Einrichtung des Continuous-Delivery-Prozesses fordern den Softwareentwickler.

\section{Lösungsansatz}

Das Gedankenexperiment zum erschwerten Continuous-Integration-Prozess offenbart die Schwäche der Methodik. Um dieses Szenario zu verhindern, müssen Konflikte bereits im Vorfeld durch die existierenden Methodiken der Softwarearchitektur minimiert werden. Im Umfeld der Softwareentwicklung mit Continuous-Integration sind solche Methodiken bereits bekannt. Insbesondere durch Modularisierung der Software-Anwendung können viele Konflikte verhindert werden. Auch durch Test-First-Ansätze werden Softwareanwendungen modularer und klarer strukturiert. Diese Ansätze fördern unter anderem \glqq lose gekoppelte\grqq{}  Softwarearchitekturen, da diese leichter durch Tests validiert werden können. 

Unabhängig von den gewählten Entwicklungsansätzen können durch Metriken\\ Schwachpunkte in den Softwarekomponenten gefunden werden. Hohe Komplexität oder Komponenten mit besonders vielen Abhängigkeiten lassen sich gut durch Metriken ausfindig machen. Visualisierung der Metriken erleichtern deren Interpretation bei besonders umfangreichen Softwareanwendungen. 

\section{Bewertung der Hypothesen}

In den vorangegangenen Absätzen wurde die Annäherung von Continuous-Integration und Feature-Branches dargelegt. An keiner Stelle konnte jedoch ein vollständiger Hybrid beschrieben werden. Die anfängliche Hypothese \glqq Feature-Branches und Continuous-Integration sind unvereinbare Prinzipien.\grqq{} ist somit korrekt. Die Kombination aus Feature-Branches und den Ansätzen von Continuous-Integration führt jedoch zu einem fortschrittlichen Softwareentwicklungsprozess.

Dieser fortschrittliche Entwicklungsprozess weist weiterhin Schwächen auf und erfordert einen hohen initialen Aufwand, sowie ein hohes Maß an Expertise von den Softwareentwicklern. Dies führt zur zweiten Hypothese. 

\glqq Continuous-Delivery ist zu komplex, um es in jedem Projekt zu verwenden.\grqq{}
\\
Die Hypothese zielt nicht auf den Konflikt zwischen Feature-Branches und Continuous-Integration. Vielmehr wird die Komplexität des automatisierten Softwareerstellungsprozesses kritisiert. Dies führt wieder zu den beiden Voraussetzungen des hohen initial Aufwandes und der notwendigen Expertise. Somit ist die Hypothese korrekt. Es existieren Software-Projekte in denen weder die Mittel für den initial Aufwand, noch für die notwendige Expertise vorhanden sind. Besteht jedoch bereits die notwendige Infrastruktur, sind die notwendige Expertise und die Anwendungskosten gering. 
\\
Abschließend wird die Hypothese zur Qualitätsverbesserung geprüft.

\glqq Der Einsatz von Continuous-Delivery steigert die Qualität des Entwicklungsprozesses.\grqq{}
\\
Continuous-Delivery fordert eine Standardisierung der Auslieferung der Softwareanwendung. Zudem werden Methoden zur Verbesserung der Testabdeckung und der Absicherung von Abhängigkeiten propagiert. Durch die mangelnde einheitliche Definition von Continuous-Delivery kann die Hypothese jedoch nicht als korrekt gewertet werden. Es ist theoretisch möglich einen Continuous-Delivery-Prozess zu erstellen, der keine Auswirkung auf die Qualität der Softwareanwendung ausübt.

\section{Ausblick}

Die weitere Betrachtung des Themas könnte vor allem in zwei Richtungen führen. Zum einen kann der eigentliche Vorgang verbessert werden, Änderungen mit einem Merge zusammenzuführen. Es existieren bereits semantische Verfahren, um die Durchführung eines Merge zu optimieren. Dadurch treten weniger Merge-Konflikte auf. Ebenso existieren Studien, die existierende Software-Repositories analysieren. Die darin existierenden Merge-Entscheidungen werden genutzt, um ein neurales Netz anzulernen. Beide Verfahren haben das Potential die Kombination aus Continuous-Integration und Feature-Branches effizienter zu gestalten.

Die zweite Richtung ist die weitere Standardisierung von Software. In einem vollständig entkoppelten System würden theoretisch nahezu keine Merge-Konflikte auftreten. Nahezu jeder Feature-Branch, der die automatische Validierung besteht, kann somit integriert werden. Angewendet innerhalb eines vollständig automatisierten Continuous-Deployment-Prozesses ergeben sich somit zahlreiche Möglichkeiten. Ein entsprechend aufgestelltes Entwicklungsteam, kann neue Änderungen direkt auf dem Produktivsystem evaluieren. Ein fortschrittlicher Continuous-Deployment-Prozess stellt die Möglichkeit bereit, eine sehr kleine Gruppe an Nutzern auszuwählen und nur diesen die Änderung anzubieten.

Die Softwareentwicklung hat in den letzten 30 Jahren zahlreiche neue Konzepte entwickelt und in der Praxis erprobt. In spannenden und hitzig geführte Diskussionen wurde darüber gestritten. Viele der entstandenen Konzepte haben die Softwareentwicklung nachhaltig geprägt. Die agile Softwareentwicklung ist das wohl prominenteste Beispiel dafür. Zahlreiche Konzepte und Methoden sind aus den Ideen und Sichtweisen der agilen Softwareentwicklung entstanden. Welche neuen Verfahren die Softwareentwicklung hervorbringt, bleibt offen. Wie bessere semantische Verfahren und der Einsatz von maschinellem Lernen die Softwareentwicklung verändern werden, wird die Zukunft zeigen. Eines bleibt jedoch sicher, die Softwareentwicklung wird auch weiterhin große Herausforderung bereithalten.

\blockquote {For a long time it puzzled me how something so expensive, so leading edge, could be so useless. And then it occurred to me that a computer is a stupid machine with the ability to do incredibly smart things, while computer programmers are smart people with the ability to do incredibly stupid things. They are, in short, a perfect match. \\- Bill Bryson}
