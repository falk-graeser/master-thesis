\chapter{Methodiken und Visualisierung für Continuous Integration und Feature Branches}
\label{ch:visu_meth}

Im vorangegangenen Kapitel wird dargelegt was Continuous-Integration und Feature-Branches sind und wie diese Techniken in der Softwareentwicklung angewendet werden. Zudem wird angerissen, welche Schwierigkeiten mit der Verwendung dieser Techniken einhergehen und dementsprechend eine Lösung erfordern. 
Die nachfolgenden Abschnitte sollen Lösungsansätze beleuchten und hilfreich Informationsquellen aufzeigen.

\section{Entwicklungs-Workflows}

Entwicklungs-Workflows sind ein stark von subjektiven Einflüssen geprägtes Themenfeld. Faktoren wie die verwendete Programmiersprache, verwendete Hilfsmittel und die vorherrschende Entwicklungskultur beeinflussen sich gegenseitig.

Kritik an Feature-Branches hängt an der Verwendung der Technik. Integration ist auch möglich ohne Trunk-Based-Development zu betreiben. Um Feature-Branches vollständig zu "ermächtigen" (wtf x'D) sind Techniken wie Virtualisierung, automatisches Bauen, Testabdeckung, Modularisierung, DependencyMgmt, Konfigurationsmgmt notwendig

\subsection{Continuous-Delivery und Feature Branches}

Die automatische Erstellung der Software pro Feature Branch ist ein notwendiges Kriterium für die Bewertung der Einzeländerung.

\subsubsection{Konfigurations- und Abhängigkeitsverwaltung}
- regeln für konfig.mgmt
- regeln für interne und externe abhängigkeiten
- updatestrategien
- konfigurationsstrategien
\subsubsection{Virtualisierung}
- Virtualisierung ermöglicht erst die Bewertung jedes Branches einzeln, sowie die Parallelisierung dieses Vorganges
\subsection{Modularisierung von Software}
- Modularisierung von Software durch strukturierte Anforderungen, Architektur, ermöglicht einfacheres zusammenführen von Feature-Branches
\section{Automatisierten Wertschöpfung}
\subsection{Metriken}
\label{subsec:auto-values-metrics}
\subsection{Automatisches Zusammenführen}
\subsubsection{Fastforward-Merges}
\subsubsection{Flüchtige Release-Branches}
- Test ob Release gebaut werden kann (automatischer Merge von allen als Release-Fähig markierten Branches
- Ermittelung von Konflikten
- Ermittelung ob Test auch ohne Änderungen lauffähig
\subsection{Automatisierte Erstellung von graphischen Übersichten}
\subsubsection{Abhängigkeitsübersicht}
- Darstellung von verwendeten Abhängigkeiten (intern und extern)
- Ermittelung der Güte von Abhängigkeiten
- Ermittelung von grenzwertigen Abhängigkeiten (deprecated, update verfügbar, sehr alt)
\subsubsection{Branch-Übersicht}
- Übersichtliche Branch-Darstellung mit Alter, Puls, Güte und Abhängigkeiten (abhäng. zu autom. Release-Erstellung)
\subsubsection{Konfigurations- und Umgebungsübersicht}
- Übersicht über alle erreichbaren Systeme und ihren Platz in der Build-Pipline / bzw mit System, und Stand / Güte
\section{Entwicklerdisziplin - Faktor Mensch}
\label{sec:human-fail}
- Testabdeckung
- Einhaltung des Prozesses
- Güte der Reviews, Reviews überhaupt
- Projektdruck
- Subjektive Bewertung von Prozess, Tools und Projekt

\begin{itemize}
\item Metriken um Branches zu beurteilen
\item automatisierte Releasekombination
\item automatisierte Konflikterkennung
\item Regeln, wie 
	\begin{itemize}
		\item nur FastForward-Merges erlauben
	\end{itemize}	 
\item verschiedene Sichten, u.a. Feature-Sicht mit Goals?
\item packetverwaltung mit einbeziehen - sind packete outdated?
\item "wervolle tests" - kopplung mit anforderungen - gherkin?
\item graphentheorie für besseres dependency management / bessere module entwerfen?
\item lose gekoppelte software ?
\end{itemize}

\blockquote {discipline, the most lacking virtue in creative people (like programmers)}
\footcite[Making only one change per commit][]{git-essentials-2017}
\footcite[Writing commit messages before starting to code][]{git-essentials-2017}

Including the whole change in one commit

Describing the change, not what have you done



\section{Disziplin und Strukturierung}
\subsection{Arbeitsweise mit Git}

Wie auch mit jeder anderen Versionsverwaltung, so ist es auch beim Arbeiten mit Git essentiell seine Arbeit zu strukturieren. Wird Git lediglich als bequeme Variante für eine regelmäßige Sicherung des Arbeitsstandes genutzt, dann entsteht sehr schnell eine schwer zu lesende, an Bedeutung mangelnde Versionshistorie. Wichtig ist es die getätigte Arbeit in semantisch zusammenhängenden, möglichst kleine und prägnanten Commits zu gliedern.
Zusammen mit nachvollziehbaren und klaren Commit-Nachrichten, entsteht so eine gut leserliche und die Dokumentation unterstützende Versionshistorie.\footcite[Making only one change per commit][]{git-essentials-2017}