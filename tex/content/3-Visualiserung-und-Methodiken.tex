\chapter{Methodiken und Visualisierung für Continuous Integration und Feature Branches}
\label{ch:visu_meth}

Im vorangegangenen Kapitel wird dargelegt was Continuous-Integration und Feature-Branches sind und wie diese Techniken in der Softwareentwicklung angewendet werden. Zudem wird darf eingegangen, welche Schwierigkeiten mit der Verwendung dieser Techniken einhergehen und dementsprechend eine Lösung erfordern. 
Die nachfolgenden Abschnitte sollen Lösungsansätze beleuchten und hilfreich Informationsquellen aufzeigen. Es wird auf Schwierigkeiten von bekannten Techniken und Methodiken eingegangen und erläutert wie häufige Fallstricke vermieden werden können.

\section{Continuous-Integration und Feature Branches}

Continuous-Integration und Feature-Branches sind beides Techniken, um die Kollaboration zwischen Entwicklern zu fördern. Continuous-Integration fordert die Integration in den existierend Codestand für jede Änderung. Durch die Verwendung des Trunk-Based-Developments, ist das gesamte Team von dieser Integration direkt betroffen. Ist die Integration fehlerhaft, wird somit für die Dauer der Behebung das gesamte Team angehalten bei der Behebung zu helfen. Der Feature-Branch-Ansatz hingegen lässt Änderung ohne Integration parallel existieren. Folgt man der Gitflow-Verwendung von Feature-Branches aus Kapitel~\ref{subsec:gitflow}, wird auch hier eine Integration vor einem Release gefordert. Feature-Branches bieten somit einen Integrationsvorgang ohne das Team zu blockieren. Allerdings wird der Zeitpunkt der Integration verzögert. In dieser Zeitspanne können weitere Änderungen zum Integrations-Branch hinzukommen. Jeder dieser Änderungen muss wiederum in den Feature-Branch integriert werden. Damit steigt der Aufwand sukzessive über die Lebensdauer des Feature-Branches. Im ungünstigsten Fall eskaliert dieser Vorgang in einem ``big scary merge'' oder ``big bang merge'' wie in Kapitel~\ref{sec:feature-branches} beschrieben. Dieses Risiko sollte gemindert werden durch eine regelmäßige Integration mit dem Integrations-Branch. 

todo: beide blockzitate besser einbauen\\

Zudem sollten die beiden Gedanken beachtet werden:\\

\blockquote {Continuous is more often then you think} 
 
\blockquote {When it is painful, the way to reduce the the pain is to do it more frequently, not less}\footcite[S.24][]{humble2010} \\

Sie beschreiben den Konflikt, welcher durch schlechte Anwendung von Continuous-Integration entsteht. 

Zielstellung der Vereinigung von Continuous-Integration und Feature-Branches ist folglich eine kontinuierliche Integration ohne Blockaden für andere Entwickler. Es muss definiert werden, wie Entwicklungssysteme und -Werkzeuge ineinander greifen und es sollten Regeln und Strukturen definiert werden, um einen Ablauf mit nur wenig Reibungspunkten zu gewährleisten.

\subsection{Automatisierter Test von Feature-Branches}

Als erste Schritt zur Verschmelzung von Continuous-Integration und Feature-Branches ist es notwendig jede Änderung automatisch zu Testen. Dazu muss jede Änderung auf einem Feature-Branch in einem zentralen Repository bereitgestellt werden. Der Stand des Feature-Branches muss dann wie in Kapitel~\ref{sec:automation-software} \nameref{sec:automation-software} beschrieben, erstellt und getestet werden.

Prinzipiell besteht die Möglichkeit einen Test der Änderungen manuell auf dem Entwicklersystem auszuführen. Dieses Vorgehen erfordert allerdings eine hohe Anzahl an Werkzeugen und blockiert den Entwickler für diesen Zeitraum.

Die Bereitstellung in einem zentralen Repository ermöglicht es statische und syntaktische Analysen zu erstellen. Die Ausführung der vollständige Test-Suite erlaubt semantische Analysen. Die zentrale Aufbereitung der Ergebnisse der Analysen ermöglicht es allen Projektteilnehmern eine Einschätzung des Feature-Branches vorzunehmen.

\subsection{Bewertung von Änderungen - Software-Metriken}
\label{subsec:main-metrics}

Tom DeMarco schrieb über Software-Metriken:

\blockquote{You can’t manage what you can’t control, and you can’t control what you
don’t measure. To be effective software engineers or software managers, we
must be able to control software development practice. If we don’t measure
it, however, we will never have that control.}\footcite{demarco1986}
\\

Um Änderungen an einer Software-Anwendung zu bewerten und automatisiert Entscheidungen zu treffen, müssen die Änderungen quantifiziert und mit Vergleichswerten in Beziehung gesetzt werden. Für die Quantifizierung können Software-Metriken aus  Kapitel~\ref{subsubsec:base-metrics} verwendet werden. Da Aussagen über Programmkomplexität und Umfang kein hinreichende Bewertung ermöglichen, müssen zudem Verfahren zur Verifikation herangezogen werden. Die üblichste Variante hierfür ist eine umfangreiche Test-Suite und je nach Anwendung auch Verfahren wie die in Kapitel~\ref{subsubsec:base-verification} beschriebene Modellprüfung und die abstrakte Interpretation.
\\
TODO: prüfen ob aussage zur Modellprüfung und abstrakten Interpretation verfeinert werden kann
\\
In der Praxis werden automatisiert oft nur Tests verwendet. Der geringer Aufwand für ihre Erstellung und eine gute Skalierbarkeit sorgen für einen flexiblen Einsatz. 

Eine Auswahl für Vergleichswerte zu treffen, ist nicht ohne weiteres möglich. Abhängig von der Beschaffenheit des Software-Projektes und der Software-Anwendung sollten andere Vergleichspunkte gewählt werden, um die Vergleichswerte zu ermitteln. In jedem Fall sollte nicht nur ein Vergleichspunkt herangezogen werden. Sowohl die Betrachtung kurzfristiger Wertänderungen, als auch die Betrachtung langfristiger Wertänderungen ist wichtig, um eine Aussage über die Qualitätsänderung treffen zu können.

\subsection{Automatisches Zusammenführen}

Das Zusammenführen von Änderungen ist ein schwieriges Unterfangen. Während der Merge von Codeständen häufig automatisch möglich ist, kann keine semantische Validierung während des Merges vorgenommen werden. Die Validierung kann durch die Ausführung einer Test-Suite erfolgen. Zusätzliche Informationen können durch die Ausführung von Metriken gewonnen werden.

\subsubsection{Fastforward-Merges}

Fastforward-Merge ist ein Term für die Versionsverwaltung mit Git. Es bezieht sich auf das Verschieben eines Branch-Zeigers zu einem anderen Branch-Zeiger ohne die Zusammenführung von Änderung. Es werden lediglich bestehende Änderung des Ziel-Branches auf den Basis-Branch übertragen.
Fastforward-Merges sind gut zu automatisieren, da sie komplett von Git durchgeführt werden können. Dadurch können verschiedene automatisierte Verfahren auf Basis eines Fastforward-Merges aufgebaut werden.

\subsubsection{Flüchtige Release-Branches}

Release-Branches sind Branches mit der Funktion alle Änderungen für eine Veröffentlichung zu einem fixen Zeitpunkt zu sammeln. Dazu werden iterativ alle Feature-Branches auf dem Release-Branch zusammen geführt. Üblicherweise wird der Feature-Branch gelöscht, nach der Zusammenführung in den Release-Branch. Der Release-Branch wird somit iterativ aufgebaut und getestet. Abschließend werden die Änderungen auf den Master-Branch überführt und mit einem Tag markiert.

Dieses Vorgehen kann zu Problemen führen, wenn Änderungen eines Feature-Branches wieder aus dem Release-Branch entfernt werden müssen. Zudem treten mögliche Merge-Fehler und -Problem erst beim Zusammenführen mit dem Release-Branch auf.

Abhilfe könnte ein ``flüchtiger''-Release-Branch schaffen. Dazu müssten alle Feature-Branches markiert werden, die einen gemeinsamen Release-Branch bilden sollen. Die Feature-Branches können automatisch zusammengeführt geführt werden. Im Gegensatz zu einem regulären Release-Branch wird zusammengeführte Branch nicht veröffentlicht. Der flüchtige Release-Branch wird für die Ausführung von Tests und die Sammlung von Metriken verwendet. Mit einer guten Test-Suite und Metriken geben diese Daten eine Aussage über den Fortschritt des Releases. Die Anzahl von Änderungen und welche Änderungen einen Konflikt verursachen, können ermittelt werden. Die erkannten Konflikten können nun frühzeitig behoben werden. Dadurch können Branches auch in Kombination beurteilt werden. Im Gegensatz zu einem öffentlichen Release-Branch können die Änderungen weiter bearbeitet werden, ohne sich Gegenseitig zu blockieren. Zudem können einzelne Features mit wenig Aufwand aus dem Release entfernt werden. Diese Option wird geschwächt durch viele kombinierende Merges um Konflikte für den Release zu entfernen.

Wie effektiv diese Technik angewendet werden kann, hängt stark vom Grad der Kopplung der Software ab. Bei einem hohen Kopplungsgrad können Releases nur schwer getrennt werden. In jedem Fall gleicht diese Technik Schwächen von Feature-Branches aus. Branches werden häufig beurteilt und Probleme werden frühzeitig kommuniziert. Abhängig von der Form der Kommunikation der Daten, kann auf diese Weise ein guter Release-Fortschritt über alle Branches ermittelt werden. 

\subsection{Automatisierte Erstellung von graphischen Übersichten}
\subsubsection{Abhängigkeitsübersicht} 
- Darstellung von verwendeten Abhängigkeiten (intern und extern)
- Ermittelung der Güte von Abhängigkeiten
- Ermittelung von grenzwertigen Abhängigkeiten (deprecated, update verfügbar, sehr alt)
\subsubsection{Branch-Übersicht}
- Übersichtliche Branch-Darstellung mit Alter, Puls, Güte und Abhängigkeiten (abhäng. zu autom. Release-Erstellung)
- löschung alter branches (verwerfen alter unnötiger änderungen)
\subsubsection{Konfigurations- und Umgebungsübersicht}
- Übersicht über alle erreichbaren Systeme und ihren Platz in der Build-Pipline / bzw mit System, und Stand / Güte

\subsection{Konfigurations- und Abhängigkeitsverwaltung}
- regeln für konfig.mgmt
- regeln für interne und externe abhängigkeiten
- updatestrategien
- konfigurationsstrategien
\subsection{Automatisierte Systembereitstellung}
- da jeder branch bewertet werden muss, müssen die tests für jeden branch ausgeführt werden
- dauert u.U. sehr lang und sollte parallelisiert werden
- container oder virtualisierung genutzt 
- container sind schneller
\section{Modularisierung von Software}
- Modularisierung von Software durch strukturierte Anforderungen, Architektur, ermöglicht einfacheres zusammenführen von Feature-Branches
- service orientiert
- lose kopplung
\section{Fortgeschrittene Nutzung von Versionsverwaltung}
Wie auch mit jeder anderen Versionsverwaltung, so ist es auch beim Arbeiten mit Git essentiell seine Arbeit zu strukturieren. Wird Git lediglich als bequeme Variante für eine regelmäßige Sicherung des Arbeitsstandes genutzt, dann entsteht sehr schnell eine schwer zu lesende, an Bedeutung mangelnde Versionshistorie. Wichtig ist es die getätigte Arbeit in semantisch zusammenhängenden, möglichst kleine und prägnanten Commits zu gliedern.
Zusammen mit nachvollziehbaren und klaren Commit-Nachrichten, entsteht so eine gut leserliche und die Dokumentation unterstützende Versionshistorie.\footcite[Making only one change per commit][]{git-essentials-2017}\footcite[Writing commit messages before starting to code][]{git-essentials-2017}

Including the whole change in one commit

Describing the change, not what have you done
\section{Testgetriebene Entwicklung}
- lieft metriken von beginn an, lieferten einen verwertbaren projektfortschritt


\section{Entwicklerdisziplin - Faktor Mensch}
\label{sec:human-fail}
\blockquote {discipline, the most lacking virtue in creative people (like programmers)}
- Testabdeckung
- Einhaltung des Prozesses
- Güte der Reviews, Reviews überhaupt
- Projektdruck
- Subjektive Bewertung von Prozess, Tools und Projekt

