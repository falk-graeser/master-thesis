\chapter{Visualisierung und Methodiken}
\label{ch:visu_meth}

\begin{itemize}
\item Metriken um Branches zu beurteilen
\item automatisierte Releasekombination
\item automatisierte Konflikterkennung
\item Regeln, wie 
	\begin{itemize}
		\item nur FastForward-Merges erlauben
	\end{itemize}	 
\item Buildautomatisierung
\item Continuous Delivery
\item Configuration Management
\item verschiedene Sichten, u.a. Feature-Sicht mit Goals?
\item packetverwaltung mit einbeziehen - sind packete outdated?
\item "wervolle tests" - kopplung mit anforderungen - gherkin?
\item graphentheorie für besseres dependency management / bessere module entwerfen?
\item lose gekoppelte software ?
\end{itemize}

\blockquote {discipline, the most lacking virtue in creative people (like programmers)}
\footcite[Making only one change per commit][]{git-essentials-2017}
\footcite[Writing commit messages before starting to code][]{git-essentials-2017}

\section{Disziplin und Strukturierung}
\subsection{Arbeitsweise mit Git}

Wie auch mit jeder anderen Versionsverwaltung, so ist es auch beim Arbeiten mit Git essentiell seine Arbeit zu strukturieren. Wird Git lediglich als bequeme Variante für eine regelmäßige Sicherung des Arbeitsstandes genutzt, dann entsteht sehr schnell eine schwer zu lesende, an Bedeutung mangelnde Versionshistorie. Wichtig ist es die getätigte Arbeit in semantisch zusammenhängenden, möglichst kleine und prägnanten Commits zu gliedern.
Zusammen mit nachvollziehbaren und klaren Commit-Nachrichten, entsteht so eine gut leserliche und die Dokumentation unterstützende Versionshistorie.\footcite[Making only one change per commit][]{git-essentials-2017}